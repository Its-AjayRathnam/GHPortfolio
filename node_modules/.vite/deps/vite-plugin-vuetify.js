import {
  __commonJS,
  __toESM,
  camelize,
  capitalize
} from "./chunk-6SSRW7KQ.js";

// browser-external:node:module
var require_node_module = __commonJS({
  "browser-external:node:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:module" has been externalized for browser compatibility. Cannot access "node:module.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/upath/build/code/upath.js
var require_upath = __commonJS({
  "node_modules/upath/build/code/upath.js"(exports) {
    var VERSION = "2.0.1";
    var extraFn;
    var extraFunctions;
    var isFunction;
    var isString;
    var isValidExt;
    var name;
    var path3;
    var propName;
    var propValue;
    var toUnix;
    var upath;
    var slice = [].slice;
    var indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
    var hasProp = {}.hasOwnProperty;
    path3 = require_path();
    isFunction = function(val) {
      return typeof val === "function";
    };
    isString = function(val) {
      return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
    };
    upath = exports;
    upath.VERSION = typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "NO-VERSION";
    toUnix = function(p) {
      p = p.replace(/\\/g, "/");
      p = p.replace(new RegExp("(?<!^)\\/+", "g"), "/");
      return p;
    };
    for (propName in path3) {
      propValue = path3[propName];
      if (isFunction(propValue)) {
        upath[propName] = /* @__PURE__ */ function(propName2) {
          return function() {
            var args, result;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            args = args.map(function(p) {
              if (isString(p)) {
                return toUnix(p);
              } else {
                return p;
              }
            });
            result = path3[propName2].apply(path3, args);
            if (isString(result)) {
              return toUnix(result);
            } else {
              return result;
            }
          };
        }(propName);
      } else {
        upath[propName] = propValue;
      }
    }
    upath.sep = "/";
    extraFunctions = {
      toUnix,
      normalizeSafe: function(p) {
        var result;
        p = toUnix(p);
        result = upath.normalize(p);
        if (p.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
          result = "./" + result;
        } else if (p.startsWith("//") && !result.startsWith("//")) {
          if (p.startsWith("//./")) {
            result = "//." + result;
          } else {
            result = "/" + result;
          }
        }
        return result;
      },
      normalizeTrim: function(p) {
        p = upath.normalizeSafe(p);
        if (p.endsWith("/")) {
          return p.slice(0, +(p.length - 2) + 1 || 9e9);
        } else {
          return p;
        }
      },
      joinSafe: function() {
        var p, p0, result;
        p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        result = upath.join.apply(null, p);
        if (p.length > 0) {
          p0 = toUnix(p[0]);
          if (p0.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
            result = "./" + result;
          } else if (p0.startsWith("//") && !result.startsWith("//")) {
            if (p0.startsWith("//./")) {
              result = "//." + result;
            } else {
              result = "/" + result;
            }
          }
        }
        return result;
      },
      addExt: function(file, ext) {
        if (!ext) {
          return file;
        } else {
          if (ext[0] !== ".") {
            ext = "." + ext;
          }
          return file + (file.endsWith(ext) ? "" : ext);
        }
      },
      trimExt: function(filename, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9e9);
        } else {
          return filename;
        }
      },
      removeExt: function(filename, ext) {
        if (!ext) {
          return filename;
        } else {
          ext = ext[0] === "." ? ext : "." + ext;
          if (upath.extname(filename) === ext) {
            return upath.trimExt(filename, [], ext.length);
          } else {
            return filename;
          }
        }
      },
      changeExt: function(filename, ext, ignoreExts, maxSize) {
        if (maxSize == null) {
          maxSize = 7;
        }
        return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? "" : ext[0] === "." ? ext : "." + ext);
      },
      defaultExt: function(filename, ext, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename;
        } else {
          return upath.addExt(filename, ext);
        }
      }
    };
    isValidExt = function(ext, ignoreExts, maxSize) {
      if (ignoreExts == null) {
        ignoreExts = [];
      }
      return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function(e) {
        return (e && e[0] !== "." ? "." : "") + e;
      }), ext) < 0;
    };
    for (name in extraFunctions) {
      if (!hasProp.call(extraFunctions, name))
        continue;
      extraFn = extraFunctions[name];
      if (upath[name] !== void 0) {
        throw new Error("path." + name + " already exists.");
      } else {
        upath[name] = extraFn;
      }
    }
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@vuetify/loader-shared/dist/index.mjs
var import_node_module = __toESM(require_node_module(), 1);
var import_upath = __toESM(require_upath(), 1);
function parseTemplate(source) {
  const components = createSet(source.matchAll(/(?:var|const) (\w+) = _resolveComponent\("([\w-.]+)"\);?/gm));
  const directives = createSet(source.matchAll(/(?:var|const) (\w+) = _resolveDirective\("([\w-.]+)"\);?/gm));
  return { components, directives };
}
function createSet(matches) {
  return new Set(Array.from(matches, (i) => ({
    symbol: i[1],
    name: capitalize(camelize(i[2])),
    index: i.index,
    length: i[0].length
  })));
}
var require$1 = (0, import_node_module.createRequire)(import.meta.url);
var importMap = require$1("vuetify/dist/json/importMap.json");
var importMapLabs = require$1("vuetify/dist/json/importMap-labs.json");
function getImports(source, options) {
  const { components, directives } = parseTemplate(source);
  const resolvedComponents = [];
  const resolvedDirectives = [];
  const imports = /* @__PURE__ */ new Map();
  const ignore = isObject(options.autoImport) && options.autoImport.ignore || null;
  const includeLabs = isObject(options.autoImport) && options.autoImport.labs;
  const map = includeLabs ? {
    components: { ...importMap.components, ...importMapLabs.components },
    directives: importMap.directives
  } : importMap;
  if (components.size || directives.size) {
    components.forEach((component) => {
      if (ignore == null ? void 0 : ignore.includes(component.name))
        return;
      if (component.name in importMap.components) {
        resolvedComponents.push(component);
      } else if (includeLabs && component.name in importMapLabs.components) {
        resolvedComponents.push(component);
      }
    });
    directives.forEach((directive) => {
      if (importMap.directives.includes(directive.name) && !(ignore == null ? void 0 : ignore.includes(directive.name))) {
        resolvedDirectives.push(directive);
      }
    });
  }
  resolvedComponents.forEach((component) => {
    addImport(imports, component.name, component.symbol, "vuetify/lib/" + map.components[component.name].from);
  });
  resolvedDirectives.forEach((directive) => {
    addImport(imports, directive.name, directive.symbol, "vuetify/lib/directives/index.mjs");
  });
  return {
    imports,
    components: resolvedComponents,
    directives: resolvedDirectives
  };
}
function addImport(imports, name, as, from) {
  if (!imports.has(from)) {
    imports.set(from, []);
  }
  imports.get(from).push(`${name} as ${as}`);
}
function generateImports(source, options) {
  const { imports, components, directives } = getImports(source, options);
  let code = "";
  if (components.length || directives.length) {
    code += "\n\n/* Vuetify */\n";
    Array.from(imports).sort((a, b) => a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0).forEach(([from, names]) => {
      code += `import { ${names.join(", ")} } from "${from}"
`;
    });
    code += "\n";
    source = [...components, ...directives].reduce((acc, v) => {
      return acc.slice(0, v.index) + " ".repeat(v.length) + acc.slice(v.index + v.length);
    }, source);
    if (!source.includes("_resolveComponent(")) {
      source = source.replace("resolveComponent as _resolveComponent, ", "");
    }
    if (!source.includes("_resolveDirective(")) {
      source = source.replace("resolveDirective as _resolveDirective, ", "");
    }
  }
  return { code, source };
}
var require2 = (0, import_node_module.createRequire)(import.meta.url);
function resolveVuetifyBase() {
  return import_upath.default.dirname(require2.resolve("vuetify/package.json", { paths: [process.cwd()] }));
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function includes(arr, val) {
  return arr.includes(val);
}
function normalizePath(p) {
  p = import_upath.default.normalize(p);
  return /^[a-z]:\//i.test(p) ? "/" + p : p;
}
function toKebabCase(str = "") {
  return str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
}
var defaultTags = {
  video: ["src", "poster"],
  source: ["src"],
  img: ["src"],
  image: ["xlink:href", "href"],
  use: ["xlink:href", "href"]
};
var transformAssetUrls = {
  VAppBar: ["image"],
  VAvatar: ["image"],
  VBanner: ["avatar"],
  VCard: ["image", "prependAvatar", "appendAvatar"],
  VCardItem: ["prependAvatar", "appendAvatar"],
  VCarouselItem: ["src", "lazySrc", "srcset"],
  VChip: ["prependAvatar", "appendAvatar"],
  VImg: ["src", "lazySrc", "srcset"],
  VListItem: ["prependAvatar", "appendAvatar"],
  VNavigationDrawer: ["image"],
  VParallax: ["src", "lazySrc", "srcset"],
  VToolbar: ["image"]
};
for (const [tag, attrs] of Object.entries(transformAssetUrls)) {
  attrs.forEach((attr) => {
    if (/[A-Z]/.test(attr)) {
      attrs.push(toKebabCase(attr));
    }
  });
  transformAssetUrls[toKebabCase(tag)] = attrs;
}
Object.assign(transformAssetUrls, defaultTags);

// node_modules/vite-plugin-vuetify/dist/index.mjs
var import_path = __toESM(require_path(), 1);
var import_url = __toESM(require_url(), 1);
var import_upath2 = __toESM(require_upath(), 1);
function parseId(id) {
  const [pathname, query] = id.split("?");
  return {
    query: query ? Object.fromEntries(new import_url.URLSearchParams(query)) : null,
    path: pathname ?? id
  };
}
function importPlugin(options) {
  return {
    name: "vuetify:import",
    configResolved(config) {
      if (config.plugins.findIndex((plugin) => plugin.name === "vuetify:import") < config.plugins.findIndex((plugin) => plugin.name === "vite:vue")) {
        throw new Error("Vuetify plugin must be loaded after the vue plugin");
      }
    },
    async transform(code, id) {
      const { query, path: path3 } = parseId(id);
      if ((!query || !("vue" in query)) && (0, import_path.extname)(path3) === ".vue" && !/^import { render as _sfc_render } from ".*"$/m.test(code) || query && "vue" in query && (query.type === "template" || query.type === "script" && query.setup === "true")) {
        const { code: imports, source } = generateImports(code, options);
        return {
          code: source + imports,
          map: null
        };
      }
      return null;
    }
  };
}
function isSubdir(root, test) {
  const relative = import_upath2.default.relative(root, test);
  return relative && !relative.startsWith("..") && !import_upath2.default.isAbsolute(relative);
}
function stylesPlugin(options) {
  const vuetifyBase = resolveVuetifyBase();
  let configFile;
  const tempFiles = /* @__PURE__ */ new Map();
  return {
    name: "vuetify:styles",
    enforce: "pre",
    configResolved(config) {
      if (isObject(options.styles)) {
        if (import_upath2.default.isAbsolute(options.styles.configFile)) {
          configFile = options.styles.configFile;
        } else {
          configFile = import_upath2.default.join(config.root || process.cwd(), options.styles.configFile);
        }
      }
    },
    async resolveId(source, importer, { custom }) {
      if (source === "vuetify/styles" || importer && source.endsWith(".css") && isSubdir(vuetifyBase, import_upath2.default.isAbsolute(source) ? source : importer)) {
        if (options.styles === "none") {
          return "\0__void__";
        } else if (options.styles === "sass") {
          const target = source.replace(/\.css$/, ".sass");
          return this.resolve(target, importer, { skipSelf: true, custom });
        } else if (isObject(options.styles)) {
          const resolution = await this.resolve(source, importer, { skipSelf: true, custom });
          if (!resolution)
            return null;
          const target = resolution.id.replace(/\.css$/, ".sass");
          const file = import_upath2.default.relative(import_upath2.default.join(vuetifyBase, "lib"), target);
          const contents = `@use "${normalizePath(configFile)}"
@use "${normalizePath(target)}"`;
          tempFiles.set(file, contents);
          return `\0plugin-vuetify:${file}`;
        }
      } else if (source.startsWith("/plugin-vuetify:")) {
        return "\0" + source.slice(1);
      } else if (source.startsWith("/@id/__x00__plugin-vuetify:")) {
        return "\0" + source.slice(12);
      }
      return null;
    },
    load(id) {
      if (/^\0__void__(\?.*)?$/.test(id)) {
        return "";
      }
      if (id.startsWith("\0plugin-vuetify")) {
        const file = /^\0plugin-vuetify:(.*?)(\?.*)?$/.exec(id)[1];
        return tempFiles.get(file);
      }
      return null;
    }
  };
}
function vuetify(_options = {}) {
  const options = {
    autoImport: true,
    styles: true,
    ..._options
  };
  const plugins = [];
  if (options.autoImport) {
    plugins.push(importPlugin(options));
  }
  if (includes(["none", "sass"], options.styles) || isObject(options.styles)) {
    plugins.push(stylesPlugin(options));
  }
  return plugins;
}
vuetify.transformAssetUrls = transformAssetUrls;
export {
  vuetify as default,
  transformAssetUrls
};
//# sourceMappingURL=vite-plugin-vuetify.js.map
