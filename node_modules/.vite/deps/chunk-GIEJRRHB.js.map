{
  "version": 3,
  "sources": ["../../vuetify/src/composables/border.ts", "../../vuetify/src/composables/elevation.ts", "../../vuetify/src/composables/position.ts", "../../vuetify/src/composables/router.tsx"],
  "sourcesContent": ["// Utilities\nimport { computed, isRef } from 'vue'\nimport { getCurrentInstanceName, propsFactory } from '@/util'\n\n// Types\nexport interface BorderProps {\n  border?: boolean | number | string\n}\n\n// Composables\nexport const makeBorderProps = propsFactory({\n  border: [Boolean, Number, String],\n}, 'border')\n\nexport function useBorder (\n  props: BorderProps,\n  name = getCurrentInstanceName(),\n) {\n  const borderClasses = computed(() => {\n    const border = isRef(props) ? props.value : props.border\n    const classes: string[] = []\n\n    if (border === true || border === '') {\n      classes.push(`${name}--border`)\n    } else if (\n      typeof border === 'string' ||\n      border === 0\n    ) {\n      for (const value of String(border).split(' ')) {\n        classes.push(`border-${value}`)\n      }\n    }\n\n    return classes\n  })\n\n  return { borderClasses }\n}\n", "// Utilities\nimport { computed, isRef } from 'vue'\nimport { propsFactory } from '@/util'\n\n// Types\nimport type { Ref } from 'vue'\nexport interface ElevationProps {\n  elevation?: number | string | null\n}\n\n// Composables\nexport const makeElevationProps = propsFactory({\n  elevation: {\n    type: [Number, String],\n    validator (v: any) {\n      const value = parseInt(v)\n\n      return (\n        !isNaN(value) &&\n        value >= 0 &&\n        // Material Design has a maximum elevation of 24\n        // https://material.io/design/environment/elevation.html#default-elevations\n        value <= 24\n      )\n    },\n  },\n}, 'elevation')\n\ntype ElevationData = {\n  elevationClasses: Ref<string[]>\n}\n\nexport function useElevation (props: ElevationProps | Ref<number | string | undefined>): ElevationData {\n  const elevationClasses = computed(() => {\n    const elevation = isRef(props) ? props.value : props.elevation\n    const classes: string[] = []\n\n    if (elevation == null) return classes\n\n    classes.push(`elevation-${elevation}`)\n\n    return classes\n  })\n\n  return { elevationClasses }\n}\n", "// Utilities\nimport { computed } from 'vue'\nimport { getCurrentInstanceName, propsFactory } from '@/util'\n\n// Types\nimport type { PropType } from 'vue'\n\nconst positionValues = ['static', 'relative', 'fixed', 'absolute', 'sticky'] as const\n\ntype Position = typeof positionValues[number]\n\nexport interface PositionProps {\n  position: Position | undefined\n}\n\n// Composables\nexport const makePositionProps = propsFactory({\n  position: {\n    type: String as PropType<Position>,\n    validator: /* istanbul ignore next */ (v: any) => positionValues.includes(v),\n  },\n}, 'position')\n\nexport function usePosition (\n  props: PositionProps,\n  name = getCurrentInstanceName(),\n) {\n  const positionClasses = computed(() => {\n    return props.position ? `${name}--${props.position}` : undefined\n  })\n\n  return { positionClasses }\n}\n", "// Utilities\nimport {\n  computed,\n  nextTick,\n  onScopeDispose,\n  resolveDynamicComponent,\n  toRef,\n} from 'vue'\nimport { deepEqual, getCurrentInstance, hasEvent, IN_BROWSER, propsFactory } from '@/util'\n\n// Types\nimport type { ComputedRef, PropType, Ref, SetupContext } from 'vue'\nimport type {\n  RouterLink as _RouterLink,\n  useLink as _useLink,\n  NavigationGuardNext,\n  RouteLocationNormalizedLoaded,\n  RouteLocationRaw,\n  Router,\n  UseLinkOptions,\n} from 'vue-router'\nimport type { EventProp } from '@/util'\n\nexport function useRoute (): Ref<RouteLocationNormalizedLoaded | undefined> {\n  const vm = getCurrentInstance('useRoute')\n\n  return computed(() => vm?.proxy?.$route)\n}\n\nexport function useRouter (): Router | undefined {\n  return getCurrentInstance('useRouter')?.proxy?.$router\n}\n\nexport interface LinkProps {\n  href: string | undefined\n  replace: boolean | undefined\n  to: RouteLocationRaw | undefined\n  exact: boolean | undefined\n}\n\nexport interface LinkListeners {\n  onClick?: EventProp | undefined\n  onClickOnce?: EventProp | undefined\n}\n\nexport interface UseLink extends Omit<Partial<ReturnType<typeof _useLink>>, 'href'> {\n  isLink: ComputedRef<boolean>\n  isClickable: ComputedRef<boolean>\n  href: Ref<string | undefined>\n}\n\nexport function useLink (props: LinkProps & LinkListeners, attrs: SetupContext['attrs']): UseLink {\n  const RouterLink = resolveDynamicComponent('RouterLink') as typeof _RouterLink | string\n\n  const isLink = computed(() => !!(props.href || props.to))\n  const isClickable = computed(() => {\n    return isLink?.value || hasEvent(attrs, 'click') || hasEvent(props, 'click')\n  })\n\n  if (typeof RouterLink === 'string') {\n    return {\n      isLink,\n      isClickable,\n      href: toRef(props, 'href'),\n    }\n  }\n\n  const link = props.to ? RouterLink.useLink(props as UseLinkOptions) : undefined\n  const route = useRoute()\n\n  return {\n    isLink,\n    isClickable,\n    route: link?.route,\n    navigate: link?.navigate,\n    isActive: link && computed(() => {\n      if (!props.exact) return link.isActive?.value\n      if (!route.value) return link.isExactActive?.value\n\n      return link.isExactActive?.value && deepEqual(link.route.value.query, route.value.query)\n    }),\n    href: computed(() => props.to ? link?.route.value.href : props.href),\n  }\n}\n\nexport const makeRouterProps = propsFactory({\n  href: String,\n  replace: Boolean,\n  to: [String, Object] as PropType<RouteLocationRaw>,\n  exact: Boolean,\n}, 'router')\n\nlet inTransition = false\nexport function useBackButton (router: Router | undefined, cb: (next: NavigationGuardNext) => void) {\n  let popped = false\n  let removeBefore: (() => void) | undefined\n  let removeAfter: (() => void) | undefined\n\n  if (IN_BROWSER) {\n    nextTick(() => {\n      window.addEventListener('popstate', onPopstate)\n      removeBefore = router?.beforeEach((to, from, next) => {\n        if (!inTransition) {\n          setTimeout(() => popped ? cb(next) : next())\n        } else {\n          popped ? cb(next) : next()\n        }\n        inTransition = true\n      })\n      removeAfter = router?.afterEach(() => {\n        inTransition = false\n      })\n    })\n    onScopeDispose(() => {\n      window.removeEventListener('popstate', onPopstate)\n      removeBefore?.()\n      removeAfter?.()\n    })\n  }\n\n  function onPopstate (e: PopStateEvent) {\n    if (e.state?.replaced) return\n\n    popped = true\n    setTimeout(() => (popped = false))\n  }\n}\n"],
  "mappings": "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",
  "names": ["makeBorderProps", "propsFactory", "border", "Boolean", "Number", "String", "useBorder", "props", "name", "arguments", "length", "undefined", "getCurrentInstanceName", "borderClasses", "computed", "isRef", "value", "classes", "push", "split", "makeElevationProps", "propsFactory", "elevation", "type", "Number", "String", "validator", "v", "value", "parseInt", "isNaN", "useElevation", "props", "elevationClasses", "computed", "isRef", "classes", "push", "positionValues", "makePositionProps", "propsFactory", "position", "type", "String", "validator", "v", "includes", "usePosition", "props", "name", "arguments", "length", "undefined", "getCurrentInstanceName", "positionClasses", "computed", "useRoute", "vm", "getCurrentInstance", "computed", "proxy", "$route", "useLink", "props", "attrs", "RouterLink", "resolveDynamicComponent", "isLink", "computed", "href", "to", "isClickable", "value", "hasEvent", "toRef", "link", "undefined", "route", "useRoute", "navigate", "isActive", "exact", "isExactActive", "deepEqual", "query", "makeRouterProps", "propsFactory", "String", "replace", "Boolean", "Object"]
}
